using System;
using System.Collections.Generic;
using System.Linq;
using static QRCoder.QRCodeGenerator;

namespace QRCoder;


/// <summary>
/// Represents a QR code generator that outputs QR codes as bitmap byte arrays.
/// </summary>
// ReSharper disable once InconsistentNaming
public class BitmapByteQRCode : AbstractQRCode, IDisposable
{
    /// <summary>
    /// Initializes a new instance of the <see cref="BitmapByteQRCode"/> class.
    /// Constructor without parameters to be used in COM objects connections.
    /// </summary>
    public BitmapByteQRCode() { }

    /// <summary>
    /// Initializes a new instance of the <see cref="BitmapByteQRCode"/> class with the specified <see cref="QRCodeData"/>.
    /// </summary>
    /// <param name="data"><see cref="QRCodeData"/> generated by the QRCodeGenerator.</param>
    public BitmapByteQRCode(QRCodeData data) : base(data) { }

    /// <summary>
    /// Returns the QR code graphic as a bitmap byte array.
    /// </summary>
    /// <param name="pixelsPerModule">The number of pixels each dark/light module of the QR code will occupy in the final QR code image.</param>
    /// <returns>Returns the QR code graphic as a bitmap byte array.</returns>
    public byte[] GetGraphic(int pixelsPerModule)
        => GetGraphic(pixelsPerModule, new byte[] { 0x00, 0x00, 0x00 }, new byte[] { 0xFF, 0xFF, 0xFF });

    /// <summary>
    /// Returns the QR code graphic as a bitmap byte array.
    /// </summary>
    /// <param name="pixelsPerModule">The number of pixels each dark/light module of the QR code will occupy in the final QR code image.</param>
    /// <param name="darkColorHtmlHex">The color of the dark modules in HTML hex format.</param>
    /// <param name="lightColorHtmlHex">The color of the light modules in HTML hex format.</param>
    /// <returns>Returns the QR code graphic as a bitmap byte array.</returns>
    public byte[] GetGraphic(int pixelsPerModule, string darkColorHtmlHex, string lightColorHtmlHex)
        => GetGraphic(pixelsPerModule, HexColorToByteArray(darkColorHtmlHex), HexColorToByteArray(lightColorHtmlHex));

    /// <summary>
    /// Returns the QR code graphic as a bitmap byte array.
    /// </summary>
    /// <param name="pixelsPerModule">The number of pixels each dark/light module of the QR code will occupy in the final QR code image.</param>
    /// <param name="darkColorRgb">The color of the dark modules as an RGB byte array.</param>
    /// <param name="lightColorRgb">The color of the light modules as an RGB byte array.</param>
    /// <returns>Returns the QR code graphic as a bitmap byte array.</returns>
    public byte[] GetGraphic(int pixelsPerModule, byte[] darkColorRgb, byte[] lightColorRgb)
    {
        var sideLength = QrCodeData.ModuleMatrix.Count * pixelsPerModule;

        var moduleDarkSingle = darkColorRgb.Reverse().ToArray();
        var moduleLightSingle = lightColorRgb.Reverse().ToArray();

        // Pre-calculate color/module bytes
        var moduleDark = new byte[pixelsPerModule * 3];
        var moduleLight = new byte[pixelsPerModule * 3];
        for (int i = 0; i < pixelsPerModule; i++)
        {
            Array.Copy(moduleDarkSingle, 0, moduleDark, i * 3, 3);
            Array.Copy(moduleLightSingle, 0, moduleLight, i * 3, 3);
        }

        // Pre-calculate padding bytes
        var padding = new byte[sideLength % 4];

        // Calculate filesize (header + pixel data + padding)
        var fileSize = 54 + (3 * (sideLength * sideLength)) + (sideLength * padding.Length);


        var bmp = new List<byte>(fileSize);

        //header part 1
        bmp.AddRange(new byte[] { 0x42, 0x4D });

        // filesize
        bmp.AddRange(IntTo4Byte(fileSize));

        // header part 2
        bmp.AddRange(new byte[] { 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00 });

        //width
        bmp.AddRange(IntTo4Byte(sideLength));
        //height
        bmp.AddRange(IntTo4Byte(sideLength));

        //header end
        bmp.AddRange(new byte[] { 0x01, 0x00, 0x18, 0x00 });
        bmp.AddRange(new byte[24]);

        //Group of pixels placeholder
        var group = new byte[(int)(sideLength / pixelsPerModule) * moduleDark.Length];
        //draw qr code
        for (var x = sideLength - 1; x >= 0; x -= pixelsPerModule)
        {
            var i_x = (x + pixelsPerModule) / pixelsPerModule - 1;
            // Pre-calculate array
            for (var y = 0; y < sideLength; y += pixelsPerModule)
            {
                var module = QrCodeData.ModuleMatrix[i_x][(y + pixelsPerModule) / pixelsPerModule - 1];
                Array.Copy(module ? moduleDark : moduleLight, 0, group, y / pixelsPerModule * moduleDark.Length, moduleDark.Length);
            }
            for (int pm = 0; pm < pixelsPerModule; pm++)
            {
                // Draw pixels
                bmp.AddRange(group);

                // Add padding (to make line length a multiple of 4)
                bmp.AddRange(padding);
            }
        }
        
        return bmp.ToArray();
    }


    /// <summary>
    /// Converts a hex color string to a byte array.
    /// </summary>
    /// <param name="colorString">The hex color string to convert.</param>
    /// <returns>Returns the color as a byte array.</returns>
    private byte[] HexColorToByteArray(string colorString)
    {
        if (colorString.StartsWith("#"))
            colorString = colorString.Substring(1);
        byte[] byteColor = new byte[colorString.Length / 2];
        for (int i = 0; i < byteColor.Length; i++)
            byteColor[i] = byte.Parse(colorString.Substring(i * 2, 2), System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.InvariantCulture);
        return byteColor;
    }

    /// <summary>
    /// Converts an integer to a 4-byte array.
    /// </summary>
    /// <param name="inp">The integer to convert.</param>
    /// <returns>Returns the integer as a 4-byte array.</returns>
    private byte[] IntTo4Byte(int inp)
    {
        byte[] bytes = new byte[4];
        unchecked
        {
            bytes[3] = (byte)(inp >> 24);
            bytes[2] = (byte)(inp >> 16);
            bytes[1] = (byte)(inp >> 8);
            bytes[0] = (byte)(inp);
        }
        return bytes;
    }
}


/// <summary>
/// Provides helper functions for creating bitmap byte array QR codes.
/// </summary>
public static class BitmapByteQRCodeHelper
{
    /// <summary>
    /// Creates a bitmap byte array QR code with a single function call.
    /// </summary>
    /// <param name="plainText">The text or payload to be encoded inside the QR code.</param>
    /// <param name="pixelsPerModule">The number of pixels each dark/light module of the QR code will occupy in the final QR code image.</param>
    /// <param name="darkColorHtmlHex">The color of the dark modules in HTML hex format.</param>
    /// <param name="lightColorHtmlHex">The color of the light modules in HTML hex format.</param>
    /// <param name="eccLevel">The level of error correction data.</param>
    /// <param name="forceUtf8">Specifies whether the generator should be forced to work in UTF-8 mode.</param>
    /// <param name="utf8BOM">Specifies whether the byte-order-mark should be used.</param>
    /// <param name="eciMode">Specifies which ECI mode should be used.</param>
    /// <param name="requestedVersion">Sets the fixed QR code target version.</param>
    /// <returns>Returns the QR code graphic as a bitmap byte array.</returns>
    public static byte[] GetQRCode(string plainText, int pixelsPerModule, string darkColorHtmlHex,
        string lightColorHtmlHex, ECCLevel eccLevel, bool forceUtf8 = false, bool utf8BOM = false,
        EciMode eciMode = EciMode.Default, int requestedVersion = -1)
    {
        using var qrGenerator = new QRCodeGenerator();
        using var qrCodeData = qrGenerator.CreateQrCode(plainText, eccLevel, forceUtf8, utf8BOM, eciMode,
                requestedVersion);
        using var qrCode = new BitmapByteQRCode(qrCodeData);
        return qrCode.GetGraphic(pixelsPerModule, darkColorHtmlHex, lightColorHtmlHex);
    }

    /// <summary>
    /// Creates a bitmap byte array QR code with a single function call.
    /// </summary>
    /// <param name="txt">The text or payload to be encoded inside the QR code.</param>
    /// <param name="eccLevel">The level of error correction data.</param>
    /// <param name="size">The number of pixels each dark/light module of the QR code will occupy in the final QR code image.</param>
    /// <returns>Returns the QR code graphic as a bitmap byte array.</returns>
    public static byte[] GetQRCode(string txt, QRCodeGenerator.ECCLevel eccLevel, int size)
    {
        using var qrGen = new QRCodeGenerator();
        using var qrCode = qrGen.CreateQrCode(txt, eccLevel);
        using var qrBmp = new BitmapByteQRCode(qrCode);
        return qrBmp.GetGraphic(size);

    }
}
