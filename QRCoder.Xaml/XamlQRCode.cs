using System.Windows;
using System.Windows.Media;
using static QRCoder.QRCodeGenerator;

namespace QRCoder.Xaml;

/// <summary>
/// Represents a QR code generator that outputs QR codes as XAML DrawingImage objects.
/// </summary>
public class XamlQRCode : AbstractQRCode, IDisposable
{
    /// <summary>
    /// Constructor without params to be used in COM Objects connections
    /// </summary>
    public XamlQRCode() { }

    /// <summary>
    /// Initializes a new instance of the <see cref="XamlQRCode"/> class with the specified <see cref="QRCodeData"/>.
    /// </summary>
    /// <param name="data"><see cref="QRCodeData"/> generated by the QRCodeGenerator.</param>
    public XamlQRCode(QRCodeData data) : base(data) { }

    /// <summary>
    /// Returns a XAML DrawingImage that contains the resulting QR code.
    /// </summary>
    /// <param name="pixelsPerModule">The number of pixels each dark/light module of the QR code will occupy in the final QR code image.</param>
    /// <returns>Returns the QR code graphic as a XAML DrawingImage.</returns>
    public DrawingImage GetGraphic(int pixelsPerModule)
        => GetGraphic(pixelsPerModule, true);

    /// <summary>
    /// Returns a XAML DrawingImage that contains the resulting QR code.
    /// </summary>
    /// <param name="pixelsPerModule">The number of pixels each dark/light module of the QR code will occupy in the final QR code image.</param>
    /// <param name="drawQuietZones">Indicates if quiet zones around the QR code should be drawn.</param>
    /// <returns>Returns the QR code graphic as a XAML DrawingImage.</returns>
    public DrawingImage GetGraphic(int pixelsPerModule, bool drawQuietZones)
    {
        var drawableModulesCount = GetDrawableModulesCount(drawQuietZones);
        var viewBox = new Size(pixelsPerModule * drawableModulesCount, pixelsPerModule * drawableModulesCount);
        return GetGraphic(viewBox, new SolidColorBrush(Colors.Black), new SolidColorBrush(Colors.White), drawQuietZones);
    }

    /// <summary>
    /// Returns a XAML DrawingImage that contains the resulting QR code.
    /// </summary>
    /// <param name="viewBox">The size of the view box for the QR code.</param>
    /// <param name="drawQuietZones">Indicates if quiet zones around the QR code should be drawn.</param>
    /// <returns>Returns the QR code graphic as a XAML DrawingImage.</returns>
    public DrawingImage GetGraphic(Size viewBox, bool drawQuietZones = true)
        => GetGraphic(viewBox, new SolidColorBrush(Colors.Black), new SolidColorBrush(Colors.White), drawQuietZones);

    /// <summary>
    /// Returns a XAML DrawingImage that contains the resulting QR code with specified colors.
    /// </summary>
    /// <param name="pixelsPerModule">The number of pixels each dark/light module of the QR code will occupy in the final QR code image.</param>
    /// <param name="darkColorHex">The color of the dark modules in hexadecimal format.</param>
    /// <param name="lightColorHex">The color of the light modules in hexadecimal format.</param>
    /// <param name="drawQuietZones">Indicates if quiet zones around the QR code should be drawn.</param>
    /// <returns>Returns the QR code graphic as a XAML DrawingImage.</returns>
    public DrawingImage GetGraphic(int pixelsPerModule, string darkColorHex, string lightColorHex, bool drawQuietZones = true)
    {
        var drawableModulesCount = GetDrawableModulesCount(drawQuietZones);
        var viewBox = new Size(pixelsPerModule * drawableModulesCount, pixelsPerModule * drawableModulesCount);
        return GetGraphic(viewBox, new SolidColorBrush((Color)ColorConverter.ConvertFromString(darkColorHex)), new SolidColorBrush((Color)ColorConverter.ConvertFromString(lightColorHex)), drawQuietZones);
    }

    /// <summary>
    /// Returns a XAML DrawingImage that contains the resulting QR code with specified brushes.
    /// </summary>
    /// <param name="viewBox">The size of the view box for the QR code.</param>
    /// <param name="darkBrush">The brush for the dark modules.</param>
    /// <param name="lightBrush">The brush for the light modules.</param>
    /// <param name="drawQuietZones">Indicates if quiet zones around the QR code should be drawn.</param>
    /// <returns>Returns the QR code graphic as a XAML DrawingImage.</returns>
    public DrawingImage GetGraphic(Size viewBox, Brush darkBrush, Brush lightBrush, bool drawQuietZones = true)
    {
        var drawableModulesCount = GetDrawableModulesCount(drawQuietZones);
        var qrSize = Math.Min(viewBox.Width, viewBox.Height);
        var unitsPerModule = qrSize / drawableModulesCount;
        var offsetModules = drawQuietZones ? 0 : 4;

        var drawing = new DrawingGroup();
        drawing.Children.Add(new GeometryDrawing(lightBrush, null, new RectangleGeometry(new Rect(new Point(0, 0), new Size(qrSize, qrSize)))));

        var group = new GeometryGroup();
        double x = 0d, y = 0d;
        for (int xi = offsetModules; xi < drawableModulesCount + offsetModules; xi++)
        {
            y = 0d;
            for (int yi = offsetModules; yi < drawableModulesCount + offsetModules; yi++)
            {
                if (QrCodeData.ModuleMatrix[yi][xi])
                {
                    group.Children.Add(new RectangleGeometry(new Rect(x, y, unitsPerModule, unitsPerModule)));
                }
                y += unitsPerModule;
            }
            x += unitsPerModule;
        }
        drawing.Children.Add(new GeometryDrawing(darkBrush, null, group));

        return new DrawingImage(drawing);
    }

    private int GetDrawableModulesCount(bool drawQuietZones = true)
        => QrCodeData.ModuleMatrix.Count - (drawQuietZones ? 0 : 8);

    /// <summary>
    /// Calculates the number of units per module for the given view box size.
    /// </summary>
    /// <param name="viewBox">The size of the view box for the QR code.</param>
    /// <param name="drawQuietZones">Indicates if quiet zones around the QR code should be drawn.</param>
    /// <returns>Returns the number of units per module.</returns>
    public double GetUnitsPerModule(Size viewBox, bool drawQuietZones = true)
    {
        var drawableModulesCount = GetDrawableModulesCount(drawQuietZones);
        var qrSize = Math.Min(viewBox.Width, viewBox.Height);
        return qrSize / drawableModulesCount;
    }
}

/// <summary>
/// Provides static methods for creating XAML DrawingImage QR codes.
/// </summary>
public static class XamlQRCodeHelper
{
    /// <summary>
    /// Creates a XAML DrawingImage QR code with a single function call.
    /// </summary>
    /// <param name="plainText">The text or payload to be encoded inside the QR code.</param>
    /// <param name="pixelsPerModule">The number of pixels each dark/light module of the QR code will occupy in the final QR code image.</param>
    /// <param name="darkColorHex">The color of the dark modules in hexadecimal format.</param>
    /// <param name="lightColorHex">The color of the light modules in hexadecimal format.</param>
    /// <param name="eccLevel">The level of error correction data.</param>
    /// <param name="forceUtf8">Specifies whether the generator should be forced to work in UTF-8 mode.</param>
    /// <param name="utf8BOM">Specifies whether the byte-order-mark should be used.</param>
    /// <param name="eciMode">Specifies which ECI mode should be used.</param>
    /// <param name="requestedVersion">Sets the fixed QR code target version.</param>
    /// <param name="drawQuietZones">Indicates if quiet zones around the QR code should be drawn.</param>
    /// <returns>Returns the QR code graphic as a XAML DrawingImage.</returns>
    public static DrawingImage GetQRCode(string plainText, int pixelsPerModule, string darkColorHex, string lightColorHex, ECCLevel eccLevel, bool forceUtf8 = false, bool utf8BOM = false, EciMode eciMode = EciMode.Default, int requestedVersion = -1, bool drawQuietZones = true)
    {
        using var qrGenerator = new QRCodeGenerator();
        using var qrCodeData = qrGenerator.CreateQrCode(plainText, eccLevel, forceUtf8, utf8BOM, eciMode, requestedVersion);
        using var qrCode = new XamlQRCode(qrCodeData);
        return qrCode.GetGraphic(pixelsPerModule, darkColorHex, lightColorHex, drawQuietZones);
    }
}
